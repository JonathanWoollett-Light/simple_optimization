use image::{ImageBuffer, Luma};
use std::cmp;
use std::fs::File;
use std::io::prelude::*;
use std::sync::Arc;

fn simple_function(list: &[f64; 3], _: Option<Arc<()>>) -> f64 {
    // thread::sleep(Duration::from_millis(25));
    list.iter().sum()
}

#[derive(Debug, Clone)]
pub struct Pixel {
    /// The red component.
    #[cfg(debug_assertions)]
    pub r: u8,
    /// The green component.
    #[cfg(debug_assertions)]
    pub g: u8,
    /// The blue component.
    #[cfg(debug_assertions)]
    pub b: u8,
    /// The luma component (`luma=(r+g+b)/3`)
    pub luma: u8,
}
#[cfg(debug_assertions)]
impl Pixel {
    /// Sets rgb values of pixel from `[u8;3]`.
    pub fn colour(&mut self, buf: [u8; 3]) {
        self.r = buf[0];
        self.b = buf[1];
        self.g = buf[2];
    }
}
// TODO change to From<[u8;3]> when `slice::array_chunks` enters stable (https://doc.rust-lang.org/std/primitive.slice.html#method.array_chunks)
//  for implementation like https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=d6b253da179b3b8303f925720cac332c
#[cfg(debug_assertions)]
impl From<&[u8]> for Pixel {
    /// Constructs pixel from array.
    fn from(buf: &[u8]) -> Pixel {
        debug_assert!(buf.len() == 3);

        Pixel {
            r: buf[0],
            g: buf[1],
            b: buf[2],
            luma: buf[0] / 3 + buf[1] / 3 + buf[2] / 3,
        }
    }
}
#[cfg(not(debug_assertions))]
impl From<&u8> for Pixel {
    /// Constructs pixel from u8 luma.
    fn from(x: &u8) -> Pixel {
        Pixel { luma: *x }
    }
}
// TODO Could these not be `impl From<Pixel> for [u8;3]`?
#[cfg(debug_assertions)]
impl From<Pixel> for Vec<u8> {
    /// Constructs vec from pixel.
    fn from(pixel: Pixel) -> Vec<u8> {
        vec![pixel.r, pixel.g, pixel.b]
    }
}
#[cfg(not(debug_assertions))]
impl From<Pixel> for Vec<u8> {
    /// Constructs vec from pixel.
    fn from(pixel: Pixel) -> Vec<u8> {
        vec![pixel.luma, pixel.luma, pixel.luma]
    }
}
#[cfg(debug_assertions)]
impl From<&Pixel> for Vec<u8> {
    /// Constructs vec from pixel reference.
    fn from(pixel: &Pixel) -> Vec<u8> {
        vec![pixel.r, pixel.g, pixel.b]
    }
}

fn main() {
    // Setup
    // -------------------------------------------
    // The directory which contains the examples images to train on.
    const SAMPLES_DIR: &str = "test_images/binarization_optimization";

    type Image = Vec<Vec<Pixel>>;
    fn open_image(entry: std::fs::DirEntry) -> Image {
        // Opens image
        let path = entry.path();
        let example = image::open(&path).unwrap().to_rgb8();
        let dims = example.dimensions();
        let size = (dims.0 as usize, dims.1 as usize);
        let example_vec = example.into_raw();

        // Binarizes image
        let img_vec = from_raw(&example_vec, size);
        img_vec
    }

    println!("fml ...");
    let examples: Vec<Image> = std::fs::read_dir(format!("{}{}", SAMPLES_DIR, "/examples"))
        .unwrap()
        .map(|entry| {
            println!("load");
            open_image(entry.unwrap())
        })
        .collect();
    let targets: Vec<Image> = std::fs::read_dir(format!("{}{}", SAMPLES_DIR, "/targets"))
        .unwrap()
        .map(|entry| {
            println!("load");
            open_image(entry.unwrap())
        })
        .collect();
    // let first_image = Some(Arc::new((examples[0].clone(), targets[0].clone())));
    println!("Opened...");
    let images: Vec<_> = examples
        .into_iter()
        .zip(targets.into_iter())
        .map(|(example, target)| {
            let active_multiplier = active_error_weighting(&target);
            println!("mul: {}", active_multiplier);
            Some(Arc::new((example, target, active_multiplier)))
        })
        .collect();

    // Running the optimization
    // -------------------------------------------
    println!("Started...");
    let bests: Vec<[u8; 5]> = images
        .into_iter()
        .enumerate()
        .map(|(i, image) | {
            // let best = simple_optimization::simulated_annealing(
            //     [0..255, 0..255, 0..255, 1..255, 1..255],
            //     eval_one,
            //     image,
            //     Some(simple_optimization::Polling{ poll_rate: 100, printing: true, early_exit_minimum: None}),
            //     1.,
            //     0.1,
            //     simple_optimization::CoolingSchedule::Fast,
            //     92, // 23 * 2
            //     1.,
            // );
            let best = simple_optimization::random_search(
                [0..255, 0..255, 0..255, 1..255, 1..255],
                eval_one,
                image,
                Some(simple_optimization::Polling {
                    poll_rate: 100,
                    printing: true,
                    early_exit_minimum: None,
                    thread_execution_reporting: true,
                }),
                2000,
            );

            println!("{:04}: {:.?}", i, best); // [34, 220, 43, 253, 168]
            output_best(i, &best);
            panic!("testing");
            best
        })
        .collect();
    let serialized_bests = serde_json::to_string(&bests).unwrap();
    let mut file = File::create(format!("{}/best.txt", SAMPLES_DIR)).unwrap();
    file.write_all(serialized_bests.as_bytes()).unwrap();

    // [34, 220, 43, 253, 168]
    // TODO Do assert new values approx equal old value
    assert!(false);

    #[rustfmt::skip]
    fn to_bin_params_u8(arr: &[u8;5]) -> (u8, u8, u8, usize, usize) {
        (arr[0] as u8, arr[1] as u8, arr[2] as u8, arr[3] as usize, arr[4] as usize,)
    }

    fn eval_one(arr: &[u8; 5], opt: Option<Arc<(Image, Image, f64)>>) -> f64 {
        let bin_params = (
            arr[0] as u8,
            arr[1] as u8,
            arr[2] as u8,
            arr[3] as usize,
            arr[4] as usize,
        );
        let arc = opt.unwrap();
        // Gets average mean-squared-error
        let binary_pixels = binarize_buffer(arc.0.clone(), bin_params);
        mse(binary_pixels, &arc.1, arc.2)
    }

    // Mean-squared-error
    fn mse(prediction: Image, target: &Image, active_multiplier: f64) -> f64 {
        let n = target.len() * target[0].len();
        prediction
            .iter()
            .flatten()
            .zip(target.iter().flatten())
            .map(|(p, t)| {
                let d = difference(p, t).powf(2.);
                // If target should be positive, heavily weight error (we would rather 100 negative pixels where positive than 100 positive pixels where negative))
                if t.luma == 0 {
                    active_multiplier * d
                } else {
                    d
                }
            })
            .sum::<f64>()
            / (2. * n as f64)
    }
    #[rustfmt::skip]
    fn difference(p: &Pixel, t: &Pixel) -> f64 {
        p.luma as f64 - t.luma as f64
    }
    // Compute multiplier for active pixels in target (0) such that the possible error of all
    //  active pixels equals 50% the possible error in any prediction.
    // This weighting is to emphasizes we would rather make an inactive pixel active than an
    //  active pixel inactive.
    // By doing it as percentage we prevent creating circumstance where model is rewarded for producing a fully active image.
    fn active_error_weighting(image: &Image) -> f64 {
        // Counts number of active pixels in image
        let count: u64 = image
            .iter()
            .flatten()
            .map(|p| if p.luma == 0 { 1 } else { 0 })
            .sum();
        0.5 * (image.len() as f64 * image[0].len() as f64 / count as f64)
    }

    fn output_best(i: usize, best: &[u8; 5]) {
        let img = image::open(format!("{}/examples/{}.jpg", SAMPLES_DIR, i))
            .unwrap()
            .to_luma8();
        let dims = img.dimensions();
        let size = (dims.0 as usize, dims.1 as usize);
        let img_raw = img.into_raw();

        let img_vec = from_raw(&img_raw, (size.1, size.0));
        let binary_pixels = binarize_buffer(img_vec.clone(), to_bin_params_u8(&best));
        output_luma(&binary_pixels, &format!("{}/best/{}.jpg", SAMPLES_DIR, i));
    }
}

pub fn output_luma(pixels: &[Vec<Pixel>], name: &str) {
    let vec: Vec<u8> = pixels.iter().flatten().map(|p| p.luma).collect();
    let binary_image = ImageBuffer::<Luma<u8>, Vec<u8>>::from_raw(
        pixels[0].len() as u32,
        pixels.len() as u32,
        vec,
    )
    .expect("Image creation failed");
    binary_image
        .save(format!("{}.png", name))
        .expect("Image saving failed");
}

#[cfg(debug_assertions)]
pub fn from_raw(raw: &[u8], (_i_size, j_size): (usize, usize)) -> Vec<Vec<Pixel>> {
    debug_assert!(raw.len() % 3 == 0);

    let j_size_3 = 3 * j_size;

    (0..raw.len())
        .step_by(j_size_3)
        .map(|index| {
            raw[index..index + j_size_3]
                .chunks_exact(3)
                .map(Pixel::from)
                .collect::<Vec<Pixel>>()
        })
        .collect()
}
#[cfg(not(debug_assertions))]
pub fn from_raw(raw: &[u8], (_i_size, j_size): (usize, usize)) -> Vec<Vec<Pixel>> {
    (0..raw.len())
        .step_by(j_size)
        .map(|index| {
            raw[index..index + j_size]
                .iter()
                .map(Pixel::from)
                .collect::<Vec<Pixel>>()
        })
        .collect()
}

pub fn binarize_buffer(
    mut img: Vec<Vec<Pixel>>,
    (
        extreme_luma_boundary,
        global_luma_boundary,
        local_luma_boundary,
        local_field_reach,
        local_field_size,
    ): (u8, u8, u8, usize, usize),
) -> Vec<Vec<Pixel>> {
    debug_assert!(local_field_reach > 0);
    debug_assert!(local_field_size > 0);

    let (i_size, j_size) = (img.len(), img[0].len());

    // Gets average luma among pixels
    //  Uses `.fold()` instead of `.sum()` as sum of values will likely exceed `u8:MAX`
    // O(nm)
    let global_luma: u8 =
        (img.iter().flatten().map(|p| p.luma as u32).sum::<u32>() / (i_size * j_size) as u32) as u8;

    let global_luma_sub = global_luma.checked_sub(global_luma_boundary);
    let global_luma_add = global_luma.checked_add(global_luma_boundary);

    let i_chunks = (i_size as f32 / local_field_size as f32).ceil() as usize;
    let j_chunks = (j_size as f32 / local_field_size as f32).ceil() as usize;

    // panic!("got here {}",chunks);

    let mut local_luma: Vec<Vec<u8>> = vec![vec![u8::default(); j_chunks]; i_chunks];

    // Gets average luma in local fields
    // O((s+r)^2*(n/s)*(m/s)) : s = local field size, r = local field reach
    for (i_chunk, i) in (0..i_size).step_by(local_field_size).enumerate() {
        let i_range = zero_checked_sub(i, local_field_reach)
            ..cmp::min(i + local_field_size + local_field_reach, i_size);
        let i_range_length = i_range.end - i_range.start;
        for (j_chunk, j) in (0..j_size).step_by(local_field_size).enumerate() {
            let j_range = zero_checked_sub(j, local_field_reach)
                ..cmp::min(j + local_field_size + local_field_reach, j_size);
            let j_range_length = j_range.end - j_range.start;

            let total: u32 = i_range
                .clone()
                .map(|i_range_indx| {
                    img[i_range_indx][j_range.clone()]
                        .iter()
                        .map(|p| p.luma as u32)
                        .sum::<u32>()
                })
                .sum();

            local_luma[i_chunk][j_chunk] = (total / (i_range_length * j_range_length) as u32) as u8;
        }
    }

    // Apply binarization
    // O(nm)
    for i in 0..i_size {
        let i_group: usize = i / local_field_size; // == floor(i as f32 / local_field_size as f32) as usize
        for j in 0..j_size {
            let j_group: usize = j / local_field_size;

            // Extreme global boundaries
            // --------------------------------
            if img[i][j].luma < extreme_luma_boundary {
                img[i][j].luma = 0;

                continue;
            }
            if img[i][j].luma > 255 - extreme_luma_boundary {
                img[i][j].luma = 255;

                continue;
            }

            // Global average boundaries
            // --------------------------------
            if let Some(global_lower) = global_luma_sub {
                if img[i][j].luma < global_lower {
                    img[i][j].luma = 0;

                    continue;
                }
            }
            if let Some(global_upper) = global_luma_add {
                if img[i][j].luma > global_upper {
                    img[i][j].luma = 255;

                    continue;
                }
            }

            // Local average boundaries
            // --------------------------------
            if let Some(local) = local_luma[i_group][j_group].checked_sub(local_luma_boundary) {
                if img[i][j].luma < local {
                    img[i][j].luma = 0;

                    continue;
                }
            }
            if let Some(local) = local_luma[i_group][j_group].checked_add(local_luma_boundary) {
                if img[i][j].luma > local {
                    img[i][j].luma = 255;

                    continue;
                }
            }
            // White is the negative (false/0) colour in our binarization, thus this is our else case
            img[i][j].luma = 255;
        }
    }
    img
}

#[rustfmt::skip]
#[inline]
fn zero_checked_sub(a: usize, b: usize) -> usize { if a > b { a - b } else { 0 } }

